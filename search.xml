<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>力扣2</title>
    <url>/2020/01/06/%E5%8A%9B%E6%89%A32/</url>
    <content><![CDATA[<h1 id="两个struct-ListNode的数相加"><a href="#两个struct-ListNode的数相加" class="headerlink" title="两个struct ListNode的数相加"></a>两个struct ListNode的数相加</h1><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 </p>
<p>一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不</p>
<p>会以 0 开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p>
<p>输出：7 -&gt; 0 -&gt; 8</p>
<p>原因：342 + 465 = 807</p>
<p>需求函数：</p>
<p>struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){</p>
<p>}</p>
<p>这道编程题也需要对函数参数的类型，参数个数进行解析：</p>
<p>参数类型：返回类型是ListNode ，所以需要新建一个ListNode节点来对存储需要输出的数据，并且该节点数量是动态的波动，受原</p>
<p>有节点数数量影响的。参数个数：函数的两个参数类型都是ListNode的数据类型，存储到内容是两个非负整数。</p>
<p>过程：先判断节点的数量n，对链两个链表的节点数量进行分别遍历各个数字存在b[count]，在对各个节点的数字进行扩大：</p>
<p>10的n-1次方，得到各个数字后进行求和，也会分别得到两个链表对应的数字，再一次进行求和得到sum。</p>
<p>判断该数字的位数count，将sum数字从首位开始分解数字存在一个数组b[count]，对新建立的链表ListNode * newList节点分配count</p>
<p>个存储单元，将b数组循环遍历存储到链表节点newList节点内，</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//遍历链表：l1、l2进行数据的初始化出两个数字，然后再进行加和</span></span><br><span class="line">    <span class="comment">//链表节点的遍历：</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum1,sum2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *b1= (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(count1*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> *b2 = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(count2*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(l1)&#123; </span><br><span class="line">        b1[count]=l1.val;</span><br><span class="line">        l1=l1-&gt;next;</span><br><span class="line">        count1++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (l2)&#123;</span><br><span class="line">        b2[count]+=l2.val;</span><br><span class="line">        l2=l2-&gt;next;</span><br><span class="line">        count2++;</span><br><span class="line">    &#125;</span><br><span class="line">    b1 = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(count1*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    b2 = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(count2*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count1;i++)</span><br><span class="line">        sum1+=b1[count1]*(<span class="number">10</span>^(count1<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;count2;j++)</span><br><span class="line">        sum2+=b2[count2]*(<span class="number">10</span>^(count2<span class="number">-1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sum = sum1 + sum2;</span><br><span class="line">    <span class="keyword">int</span> ll=sum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(ll&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        ll/=<span class="number">10</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* newList=(ListNode *)<span class="built_in">malloc</span>(count*<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;count;k++)&#123;</span><br><span class="line">        newList-&gt;val=sum/<span class="number">10</span>;    </span><br><span class="line">        newList=newList-&gt;next;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">实现过程出现了许多问题。</span><br><span class="line"></span><br><span class="line">下面是我在给结构体分配N个（动态的，不确定的）数据单元存在的疑惑，现在在我进一步探索的过程里明朗了许多：</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please input N:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">stu</span> = <span class="title">NULL</span>;</span></span><br><span class="line">stu = (struct Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Student)*N); <span class="comment">//创建一个结构体含有N个数据</span></span><br></pre></td></tr></table></figure>


<h2 id="下面是例题的正确答案，实现代码："><a href="#下面是例题的正确答案，实现代码：" class="headerlink" title="下面是例题的正确答案，实现代码："></a><strong>下面是例题的正确答案，实现代码：</strong></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//初始化空头</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">head</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span>	<span class="comment">//建立新的链表头结点，分配数据空间，是返回结果集的链表</span></span><br><span class="line">	head-&gt;next =<span class="literal">NULL</span>;															<span class="comment">//头结点指向空指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tail</span>;</span>														<span class="comment">//建尾指针,用来存储两结构体数据</span></span><br><span class="line">	tail = head;																<span class="comment">//链表头尾指针地址相同，表示链表为空</span></span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p1</span> = <span class="title">l1</span>;</span>													<span class="comment">//建立参数指针的代替节点	</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p2</span> = <span class="title">l2</span>;</span>													</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> carry = <span class="number">0</span>; 																<span class="comment">//进位</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//循环，直到跳出两个链表</span></span><br><span class="line">	<span class="comment">//当两条链表一样长时只需这一次处理，</span></span><br><span class="line">	<span class="comment">//不一样长时，只能处理一样长的大小</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//同时遍历两个参数链表</span></span><br><span class="line">	<span class="keyword">while</span> (p1 != <span class="literal">NULL</span> &amp;&amp; p2 != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> sum = p1-&gt;val + p2-&gt;val + carry;								<span class="comment">//参数的两个链表的值之和</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (sum &gt;= <span class="number">10</span>)														<span class="comment">//满十进一</span></span><br><span class="line">		&#123;	</span><br><span class="line">			sum -= <span class="number">10</span>;   													<span class="comment">//当前结点的值-10，变为个位 (7+8=15)&gt;10; sum=15-10=5; </span></span><br><span class="line">			carry = <span class="number">1</span>;      												<span class="comment">//大于10，进位1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>																<span class="comment">//不满十不进位</span></span><br><span class="line">		&#123;</span><br><span class="line">			carry = <span class="number">0</span>;														</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tail-&gt;next = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));					<span class="comment">//新链表从尾节点开始增加新空间</span></span><br><span class="line">		tail = tail-&gt;next;																<span class="comment">//新空间成为新的尾节点</span></span><br><span class="line">		tail-&gt;val = sum;																<span class="comment">//为新的节点赋值</span></span><br><span class="line"></span><br><span class="line">		p1 = p1-&gt;next;																	<span class="comment">//继续遍历指向下一节点</span></span><br><span class="line">		p2 = p2-&gt;next;																	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)															<span class="comment">//遍历完后:两个链表要么同时为空，要么有一个参数链表不为空，进行判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		p1 = p2;															<span class="comment">//不管谁还剩余空节点，取出剩下的数据</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (p2 = <span class="literal">NULL</span>)														</span><br><span class="line">	&#123;</span><br><span class="line">		p1 = p1;															<span class="comment">//不管谁还剩余空节点，取出剩下的数据</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历剩下的数据</span></span><br><span class="line">	<span class="keyword">while</span> (p1 != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = p1-&gt;val + carry; 											<span class="comment">//带上进制计算当前结点和</span></span><br><span class="line">		<span class="keyword">if</span> (sum &gt;= <span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sum -= <span class="number">10</span>;</span><br><span class="line">			carry = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			carry = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//继续朝合并的链表中添加结点</span></span><br><span class="line">		tail-&gt;next = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">		tail = tail-&gt;next;</span><br><span class="line">		tail-&gt;val = sum;</span><br><span class="line">      	p1 = p1-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果最后一位还有进制，再申请一个结点存1</span></span><br><span class="line">	<span class="keyword">if</span> (carry == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		tail-&gt;next = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">		tail = tail-&gt;next;</span><br><span class="line">		tail-&gt;val = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	tail-&gt;next = <span class="literal">NULL</span>; <span class="comment">//尾指针赋空，结尾</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为我们不能返回头结点，所以要把头结点释放了，但是要头指针移到第一个结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pTemp</span> = <span class="title">head</span>;</span></span><br><span class="line">	head = head-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(pTemp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>欢迎入住Flint&#39;s blog</title>
    <url>/2020/01/06/%E6%AC%A2%E8%BF%8E%E5%85%A5%E4%BD%8FFlint&#39;s%20blog/</url>
    <content><![CDATA[<h1 id="嗯哼"><a href="#嗯哼" class="headerlink" title="嗯哼"></a>嗯哼</h1><p>大家好！<br>上线了Hexo博客，记下了这一美妙的时刻 。<br><img src="https://img-blog.csdnimg.cn/20200106025440110.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTM4MDMz,size_16,color_FFFFFF,t_70" alt="咦~"></p>
<p><strong>博客暂时营业内容:</strong></p>
<ol>
<li>全新的界面设计 ，带来新的阅读体验。</li>
<li>记录java或c语言下算法的历程。</li>
<li>分享一些有趣的小程序，分步骤过程让编码实现。<ul>
<li><input checked="" disabled="" type="checkbox"> 无障碍</li>
</ul>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200106031150298.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTM4MDMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> [1]: <a href="https://weibo.com/u/3887061132?is_all=1" target="_blank" rel="noopener">https://weibo.com/u/3887061132?is_all=1</a><br> [2]: <a href="https://github.com/miracleM78/" target="_blank" rel="noopener">https://github.com/miracleM78/</a></p>
]]></content>
  </entry>
</search>
